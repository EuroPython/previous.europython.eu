{"pageProps":{"source":{"compiledSource":"var p=Object.defineProperty,m=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var h=(t,e,a)=>e in t?p(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,n=(t,e)=>{for(var a in e||(e={}))i.call(e,a)&&h(t,a,e[a]);if(r)for(var a of r(e))s.call(e,a)&&h(t,a,e[a]);return t},c=(t,e)=>m(t,u(e));var l=(t,e)=>{var a={};for(var o in t)i.call(t,o)&&e.indexOf(o)<0&&(a[o]=t[o]);if(t!=null&&r)for(var o of r(t))e.indexOf(o)<0&&s.call(t,o)&&(a[o]=t[o]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var o=a,{components:t}=o,e=l(o,[\"components\"]);return mdx(MDXLayout,c(n(n({},layoutProps),e),{components:t,mdxType:\"MDXLayout\"}),mdx(\"article\",n({},{className:\"accent-left\"}),mdx(\"p\",{parentName:\"article\"},\"CPython\\u2019s \\u201CGlobal Interpreter Lock\\u201D, or \\u201CGIL\\u201D, prevents multiple threads from executing Python code in parallel. The GIL was added to Python in 1992 together with the original support for threads in order to protect access to the interpreter\\u2019s shared state.\"),mdx(\"p\",{parentName:\"article\"},\"Python supports a number of ways to enable parallelism within the constraints of the GIL, but they come with significant limitations. Imagine if you could avoid the startup time of joblib workers, the multiprocess instability of PyTorch\\u2019s DataLoaders, and the overhead of pickling data for inter-process communication.\"),mdx(\"p\",{parentName:\"article\"},\"The \\u201Cnogil\\u201D project aims to remove the GIL from CPython to make multithreaded Python programs more efficient, while maintaining backward compatibility and single-threaded performance. It exists as a fork, but the eventual goal is to contribute these changes upstream.\"),mdx(\"p\",{parentName:\"article\"},\"This talk will cover the changes to Python to let it run efficiently without the GIL and what these changes mean for Python programmers and extension authors.\")))}MDXContent.isMDXComponent=!0;\n","scope":{}},"path":"keynoters/sam-gross","data":{"title":"Multithreaded Python without the GIL","speaker":"Sam Gross","bio":"Sam Gross is a software engineer at Meta AI. He is a co-author of PyTorch, an open-source Python machine learning framework. He holds M.Eng. and B.S. degrees in computer science from the Massachusetts Institute of Technology.","subtitle":"Mostly thread-safe"},"bioSource":{"compiledSource":"var h=Object.defineProperty,m=Object.defineProperties;var y=Object.getOwnPropertyDescriptors;var a=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;var u=(e,o,n)=>o in e?h(e,o,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[o]=n,s=(e,o)=>{for(var n in o||(o={}))r.call(o,n)&&u(e,n,o[n]);if(a)for(var n of a(o))c.call(o,n)&&u(e,n,o[n]);return e},i=(e,o)=>m(e,y(o));var p=(e,o)=>{var n={};for(var t in e)r.call(e,t)&&o.indexOf(t)<0&&(n[t]=e[t]);if(e!=null&&a)for(var t of a(e))o.indexOf(t)<0&&c.call(e,t)&&(n[t]=e[t]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var t=n,{components:e}=t,o=p(t,[\"components\"]);return mdx(MDXLayout,i(s(s({},layoutProps),o),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"Sam Gross is a software engineer at Meta AI. He is a co-author of PyTorch, an open-source Python machine learning framework. He holds M.Eng. and B.S. degrees in computer science from the Massachusetts Institute of Technology.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"slug":"sam-gross"},"__N_SSG":true}